#как список, только элементы все уникальные
a = {1, 2, 3, "hello"}
#в множестве эелемнтами могут быть только неизменяемые типы: списки/словари/множества нельзя добавить во множество

#пустое множество
a = set()

set([1, 2, 3, 4, 5, 5, 5]) #{1, 2, 3, 4, 5}
set("blabla") #{'l', 'a', 'b'}

#обратиться к эелементу множества по индексу нельзя

#сделать из множества список
list(set([1, 2, 3, 4, 5, 5, 5])) #[1, 2, 3, 4, 5]

#перебрать множество
q = set([1, 2, 3, 4, 5, 5, 5]) #{1, 2, 3, 4, 5}
for el in q:
    print(el)
#1
#2
#3
#4
#5

#можно создать итератор для множества
it = iter(q)
next(it)

#количество эелементов в множестве
len(q) #5

#есть ли эелемент в множестве
5 in q #True

#добавление элемента в множество (по одному)
b = set()
b.add(7)
b #{7}

b.add(3)
b #{3, 7}

#добавление элемента в множество (сразу несколько)
b = set()
b.update(["a", "b", (1, 2)])
b #{'a', (1, 2), 'b'}

b = set()
b.update("blablabla")
b #{'l', 'a', 'b'}

#удаление элемента из множеста
b = {'a', (1, 2), 'b'}
b.discard('a')
b #{(1, 2), 'b'}

b.remove('b')
b #{(1, 2)}
#remove() возвратит ошибку, если мы попробуем удалить несуществующий эелемент, а метод discard() никакой ошибки в этом случае не вернет (просто множество останется как оно есть)

b = {'a', (1, 2), 'b'}
b.pop() #удаляет любой рандомный элемент и возвращает его (сейчас он удалил 'a')
b #{(1, 2), 'b'}

b.clear()#удаляет все эелементы сета
b #set()

#пересечение двух множест
setA = {1, 2, 3, 4}
setB = {3, 4, 5, 6, 7}
setA & setB #{3, 4} возварает новое множество, содержащиее общие элементы, которые находятся и там и там, пересечение
setA.intersection(setB) #{3, 4} тоже самое что setA & setB

#объединение множеств
setA = {1, 2, 3, 4}
setB = {3, 4, 5, 6, 7}
setA | setB #{1, 2, 3, 4, 5, 6, 7}
setA.union(setB) #{1, 2, 3, 4, 5, 6, 7} тоже самое что setA | setB

#вычитание одного множества из другого
setA = {1, 2, 3, 4}
setB = {3, 4, 5, 6, 7}
setA - setB #{1, 2} вычли общие элементы и остались те, которые в множество setB не входят
setB - setA #{5, 6, 7} вычли общие элементы и остались те, которые в множество setА не входят

#создать новое множество, где будут уникальные эелементы обоих множеств
#эдементы, которые есть и в setA и в setB исключаются, остаются только несовпадающие элементы
setA = {1, 2, 3, 4}
setB = {3, 4, 5, 6, 7}
setA ^ setB #{1, 2, 5, 6, 7}

#сравнение множеств
setA = {7, 6, 5, 4, 3}
setB = {3, 4, 5, 6, 7}
setA == setB #True совпадает количество элементов и совпадают значения элементов (и не важно в каком порядке они расположены)
setA != setB #False

# разница / общее

set1 = {1, 2, 3, 'one', 'ten'}
set2 = {1, 2, 3, 'one', 'ten', 100, 525}
set1.issubset(set2) # True множество set1 полностью входит во множество set2 (как бы может являться его частью) | set1 <= set2
set2.issuperset(set1) # True множество set2 содержит в себе полностью set1 | set2 >= set1

set3 = {1, 2, 3}
set2.intersection(set3) # {1, 2, 3} проверка совпадений из двух сетов (какой элемент в сетах общий)

set1 = {1, 2, 3, 'one', 'ten', 20}
set2 = {1, 2, 3, 'one', 'ten', 100, 525}
set1.difference(set2) # {20} чего нет в set2, что есть в set1 (чем set1 такой уникальный в отличие от set2)
set1.symmetric_difference(set2) # {100, 20, 525} в обе стороны: [100, 525] нет в set1, а [20] нет, а set2

set4 = {10, 50, 30}
set1.isdisjoint(set4) # True, потому что в set1 нет НИ ОДНОГО элемента, который есть в set4 (если хоть один эелемент у них будет общий, то вернет False)

# заморозить сет (в таком сете ничего нельзя менять, ни удалять, н прибавлять, ничего - он заморожен)
f_set = frozenset({1, 2, 3})

# -----

setA = {7, 6, 5, 4, 3}
setB = {3, 4, 5}
setB < setA #True setB включается в множество setA (два множества долны быть равными между собой, иначе будет Fasle)

# -----

s1 = set(map(int, input().split()))
s2 = set(map(int, input().split()))
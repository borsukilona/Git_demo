def get_V(a, b, c):
    print(f"a = {a}, b = {b}, c = {c}")
    return a * b * c


v1 = get_V(1, 2, 3) #позиционные аргументы (по порядку все чсила будут присваиваться к a, b, c)
#print(v1) #a = 1, b = 2, c = 3

v = get_V(b=1, a=2, c=3) #именнованные аргументы
#print(v) #a = 2, b = 1, c = 3


def get_VV(a, b, c, verbose=True): #verbose=True - формальный параметр, который уже имеет значение; a, b, c - фактические параметры, ибо не имеют начальных значений
    if verbose:
        print(f"a = {a}, b = {b}, c = {c}")
    return a * b * c


#при вызове функции формальные параметры не обязательно прописывать, а фактические обязательно
v3 = get_VV(1, 2, 3) #a = 1, b = 2, c = 3
v4 = get_VV(1, 2, 3, False) #6

# ----------------------------------------------------------------------------------------------------
#сравниваем две строки между собой
#функция может учитывать регистр, а может не учитывать
#фуекция может учитывать пробелы до и после или не учитывать

def cmp_str(s1, s2, reg=False, trim=True): #по умолчанию регистр не меняется (reg=False), а лишние символы (пробелы) отбрасываются (trim=True)
    if reg: #если есть разница в регистре, то мы все делаем маленьким
        s1 = s1.lower()
        s2 = s2.lower()

    if trim: #если есть какие пробелы/символы, то убираем их
        s1 = s1.strip()
        s2 = s2.strip()

    return s1 == s2


cmp_str("Python ", " Python") #True ибо лишние пробелы удаляются по умолчанию
cmp_str("Python ", " python") #False ибо по умолчанию с регистром мы ничего не делаем, поэтому строки будут разными
cmp_str("Python ", " python", reg=True) #True ибо мы таки что-то делаем с регистром, чтоб наши строки стали равны
cmp_str("Python ", " Python", trim=False) #False ибо мы отказались от отсечения пробелов вначале и в конце строки, а значит строки разные

# ----------------------------------------------------------------------------------------------------
def add_value(value, lst=[]):
    lst.append(value)
    return lst


l = add_value(1)
l = add_value(2)
#print(l) #[1, 2]
#поскольку список это изменяемый тип, то когда мы вызываем функцию первый раз, в список добавляется первый элемент и сохраняется там!
#когда мы будем вызывать функцию повторно, то элементы будут тоже сохранятся внутри
#lst ссылается на один и тот же список, который мы изменяем по ходу дела

# чтобы при каждом вызове функции создавался пустой список с одним элементом

def add_value_new(value, lst=None):
    if lst is None:
        lst = []
    lst.append(value)
    return lst

l = add_value_new(1)
l = add_value_new(2)
#print(l) #[2]
#print(add_value_new(2, l)) #[2, 2]

# ----------------------------------------------------------------------------------------------------
#произвольное количество позиционных аргументов

#формируем путь к файлу из нескольких строк
#F:\~stepik.org\Добрый, добрый Python (Питон)\39\р39. Функции.docx

def os_path(*s): #количество строк может быть любое
    path = '\\'.join(s) #соединяем все наши аргументы слешем в одну строку
    return path


#print(os_path('F:\\~stepik.org', 'Добрый, добрый Python (Питон)', '39\\р39. Функции.docx')) #F:\~stepik.org\Добрый, добрый Python (Питон)\39\р39. Функции.docx

# ----------------------------------------------------------------------------------------------------
#произвольное количество позиционных аргументов
def os_path2(*s, **kwargs):
    #**kwargs - коллекция именнованных аргументов - словарь - имя аргумента:значение;
    #содержит те именнованные аргументы, которые мы пишем когда вызываем функцию sep='/'
    #os_path2('F:\\~stepik.org', 'Добрый, добрый Python (Питон)', '39\\р39. Функции.docx', sep='/')
    path = kwargs['sep'].join(s)
    return path
    #print(kwargs) #{'sep': '/'}


#print(os_path2('F:\\~stepik.org', 'Добрый, добрый Python (Питон)', '39\\р39. Функции.docx', sep='/')) #F:\~stepik.org/Добрый, добрый Python (Питон)/39\р39. Функции.docx

# ----------------------------------------------------------------------------------------------------
def os_path3(disk, *s, sep='\\', **kwargs):
    s = (disk,) + s
    if 'trim' in kwargs and kwargs['trim'] == True:
        s = [x.strip() for x in s] #если trim будет true, то будем удалять пробелы/лишние значи вначале и конце каждой строки
    path = sep.join(s)
    return path
    #print(kwargs) #{'trim': True}


print(os_path3('F:\\',
         ' ~stepik.org ',
         'Добрый, добрый Python (Питон)',
         '39\\р39. Функции.docx',
         sep='/', trim=True))
#F:\/~stepik.org/Добрый, добрый Python (Питон)/39\р39. Функции.docx